{"version":3,"sources":["webpack://Redul/webpack/universalModuleDefinition","webpack://Redul/webpack/bootstrap","webpack://Redul/./src/utils.ts","webpack://Redul/./src/constants.ts","webpack://Redul/./interface.ts","webpack://Redul/./src/element.ts","webpack://Redul/./src/dispatcher.ts","webpack://Redul/./src/hook.ts","webpack://Redul/./src/reconcile.ts","webpack://Redul/./src/fiber.ts","webpack://Redul/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isComponent","type","EffectTag","FiberNodeTag","TEXT_ELEMENT_TYPE","ROOT_FIBER_NODE","ENOUGH_TIME","transformElementInputsToElements","args","eles","Array","isArray","concat","filter","element","isBoolean","map","props","nodeValue","children","isEvent","test","computeEventName","replace","toLowerCase","getNearestParentDom","fiberNode","currentFiberNode","parent","tag","COMPONENT_NODE","statNode","resolveFiberNode","parentDomNode","effectTag","oldDomNode","ADD","domNode","createDomNode","appendChild","REMOVE","removeChild","UPDATE","prevProps","nextProps","extractAttrsAndEventsFromProps","events","attrs","eventName","eventValue","removeEventListener","attrName","isHTMLElement","removeAttribute","removeAllDomNodeAttrsAndEvents","attachDomNodeAttrsAndEvents","updateDomNode","alternate","REPLACE","replaceChild","resolveHostFiberNode","document","createTextNode","createElement","addEventListener","nameAndValue","selectAttrNameAndValue","setAttribute","current","originValue","keys","join","dispatcher","render","rootFiberNode","effects","length","parentDom","clearDomContent","innerHTML","workInProgressHook","workInProgressFiberNode","componentUpdateQueue","isHookOnUpdateStage","isMount","mountWorkInProgressHook","hook","memoizedState","dispatch","next","hooks","updateWorkInProgressHook","baseReducer","state","action","mountUseReducer","reducer","initState","dispatchAction","updateUseReducer","isEqualDeps","prevDeps","nextDeps","Math","min","is","pushHookEffect","destroy","deps","effect","push","newState","isPartialStateChanged","oldRootFiberNode","workInProgressRootFiberNode","HOST_ROOT_NODE","createWorkInProgressRootFiberNode","taskQueue","nextUnitWork","requestIdleCallback","performWork","update","callback","didTimeout","timeRemaining","deadline","task","shift","flushTaskQueue","resolveNextUnitWork","unitWork","Component","alternateFiberNode","parentFiberNode","oldFiberNode","child","prevFiberNode","newFiberNode","mergeEffectTag","NOTHING","sibling","cloneChildFiberNodes","setWorkInProgressFiberNode","updateQueue","reconcileChildren","beginComponentNodeUnitWork","beginHostNodeUnitWork","beginUnitWork","completeUnitWork","performUnitWork","alternateParentFiberNode","prevChildFiberNode","alternateChildFiberNode","childElement","childFiberNode","transformElementToFiberNode","resolveEffectTag","resolveAlternateFiberNodesAsRemoveEffectTag","HOST_NODE","currentEffectTag","oldEffectTag","max","hookEffect","commitUnitWorkHooks","initProps","assign","containerDom","createRootFiberNode","useState","isInitStateFunc","mountUseState","useReducer","useEffect","undefined","updateUseEffect","mountUseEffect","useCallback","updateUseCallback","mountUseCallback","useMemo","nextCreate","nextValue","updateUseMemo","mountUseMemo","useRef","initValue","ref","mountUseRef"],"mappings":"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","file":"redul.production.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Redul\"] = factory();\n\telse\n\t\troot[\"Redul\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { FunctionComponent } from \"../reax\";\n\nexport function isBoolean(value: unknown): value is boolean {\n    return typeof value === 'boolean'\n}\n\nexport function arraify<T>(value: T | T[]) {\n    return Array.isArray(value) ? value : [value]\n}\n\nexport function isComponent(type?: string | FunctionComponent) {\n    return typeof type === 'function'\n}\n","export const TEXT_ELEMENT_TYPE = '@@reax/text-node'\nexport const ROOT_FIBER_NODE = '@@reax/root-fiber-node'\n\nexport const ENOUGH_TIME = 1\n","// fiber effect\nexport enum EffectTag {\n    NOTHING,\n    UPDATE,\n    REPLACE,\n    ADD,\n    REMOVE\n}\n\nexport enum FiberNodeTag {\n    HOST_ROOT_NODE = 1,\n    HOST_NODE,\n    COMPONENT_NODE\n}\n","import { isBoolean, arraify } from \"./utils\";\nimport { TEXT_ELEMENT_TYPE } from './constants'\nimport { ElementType, ElementInput, Element, ElementProps } from '../reax'\n\n// create element node\nexport function createElement(type: ElementType, initProps: ElementProps, ...args: ElementInput[]): Element {\n    const props = Object.assign({}, initProps);\n    const children = transformElementInputsToElements(args)\n\n    props.children = children;\n    return { type, props, children };\n}\n\nfunction createTextElement(text: string | number): Element<{nodeValue: string | number}> {\n    return {\n        type: TEXT_ELEMENT_TYPE,\n        props: { nodeValue: text, children: [] },\n        children: []\n    }\n}\n\nexport function transformElementInputsToElements(args: ElementInput | ElementInput[]) {\n    const eles = arraify(args)\n    const rawElements = ([] as ElementInput[]).concat(...eles).filter(element => element != null && !isBoolean(element)) as (string | number | Element)[];\n    return rawElements.map(element => element instanceof Object ? element : createTextElement(element));\n}\n","import { FiberNode, ElementProps, HTMLElementOrText } from '../redul'\nimport { EffectTag, FiberNodeTag } from '../interface'\nimport { TEXT_ELEMENT_TYPE } from './constants';\n\nconst isEvent = (key: string) => /on\\w+/.test(key)\nconst computeEventName = (key: string) => key.replace(/^on/, '').toLowerCase() as keyof HTMLElementEventMap\n\nconst dispatcher = {\n    render: (rootFiberNode: FiberNode) => {\n        const effects = rootFiberNode.effects\n        // console.log('render', effects.map(item => ([item.type, item.effectTag])))\n\n        for (let i = 0; i < effects.length; i++) {\n            const fiberNode = effects[i]\n            const parentDom = getNearestParentDom(fiberNode)\n            if (parentDom) {\n                resolveFiberNode(fiberNode, parentDom)\n                // reset effectTag\n                fiberNode.effectTag = null\n            }\n        }\n    },\n    clearDomContent(domNode: HTMLElement) {\n        domNode.innerHTML = ''\n    }\n}\n\nfunction getNearestParentDom(fiberNode: FiberNode) {\n    let currentFiberNode = fiberNode.parent;\n    while (currentFiberNode) {\n        if (currentFiberNode.tag !== FiberNodeTag.COMPONENT_NODE) {\n            return currentFiberNode.statNode\n        }\n\n        currentFiberNode = currentFiberNode.parent\n    }\n    return null\n}\n\nfunction resolveFiberNode(fiberNode: FiberNode, parentDomNode: HTMLElementOrText) {\n    if (fiberNode.tag === FiberNodeTag.COMPONENT_NODE) {\n        resolveComponentFiberNode(fiberNode, parentDomNode)\n    } else {\n        resolveHostFiberNode(fiberNode, parentDomNode)\n    }\n}\n\nfunction resolveComponentFiberNode(fiberNode: FiberNode, parentDomNode: HTMLElementOrText) {\n    // do nothing\n}\n\nfunction resolveHostFiberNode(fiberNode: FiberNode, parentDomNode: HTMLElementOrText) {\n    const effectTag = fiberNode.effectTag\n    if (!effectTag) {\n        return\n    }\n\n    const oldDomNode = fiberNode.statNode\n\n    if (effectTag === EffectTag.ADD) {\n        const domNode = createDomNode(fiberNode.type as string, fiberNode.props)\n        fiberNode.statNode = domNode\n        parentDomNode.appendChild(domNode)\n    }\n\n    if (oldDomNode) {\n        if (effectTag === EffectTag.REMOVE) {\n            parentDomNode.removeChild(oldDomNode)\n        } else if (effectTag === EffectTag.UPDATE) {\n            updateDomNode(oldDomNode, fiberNode.alternate && fiberNode.alternate.props, fiberNode.props)\n        } else if (effectTag === EffectTag.REPLACE) {\n            const domNode = createDomNode(fiberNode.type as string, fiberNode.props)\n            fiberNode.statNode = domNode\n            parentDomNode.replaceChild(domNode, oldDomNode)\n        }\n    }\n}\n\nfunction createDomNode(type: string, props: ElementProps<any>) {\n    let domNode: HTMLElementOrText | null = null\n    if (type === TEXT_ELEMENT_TYPE) {\n        // nodeValue will update later when attach attributes\n        domNode = document.createTextNode('')\n    } else {\n        domNode = document.createElement(type)\n    }\n\n    if (props) {\n        attachDomNodeAttrsAndEvents(domNode, props)\n    }\n    return domNode\n}\n\nfunction updateDomNode(domNode: HTMLElementOrText, prevProps: ElementProps<any>, nextProps: ElementProps<any>) {\n    if (nextProps) {\n        if (prevProps) {\n            removeAllDomNodeAttrsAndEvents(domNode, prevProps)\n        }\n        attachDomNodeAttrsAndEvents(domNode, nextProps)\n    }\n}\n\nfunction attachDomNodeAttrsAndEvents(domNode: HTMLElementOrText, props: ElementProps<any>) {\n    const { events, attrs } = extractAttrsAndEventsFromProps(props)\n\n    for (let eventName in events) {\n        const eventValue = events[eventName]\n        domNode.addEventListener(eventName, eventValue)\n    }\n\n    for (let attrName in attrs) {\n        // deal ref\n        if (attrName === 'ref') {\n            if (typeof attrs['ref'] === 'object') {\n                attrs['ref'].current = domNode\n            }\n            continue\n        }\n\n        const nameAndValue = selectAttrNameAndValue(attrName, attrs[attrName])\n        if (!nameAndValue) {\n            continue\n        }\n        const { name, value } = nameAndValue\n        if (isHTMLElement(domNode)) {\n            domNode.setAttribute(name, value)\n        } else if (value) {\n            domNode.nodeValue = value\n        }\n    }\n}\n\nfunction extractAttrsAndEventsFromProps(props: ElementProps<any>) {\n    let events: Partial<ElementProps<any>> = {}\n    let attrs: Partial<ElementProps<any>> = {}\n\n    for (let key in props) {\n        if (isEvent(key)) {\n            events[computeEventName(key)] = props[key]\n        } else {\n            attrs[key] = props[key]\n        }\n    }\n    return { events, attrs }\n}\n\nfunction isHTMLElement(domNode: HTMLElementOrText): domNode is HTMLElement {\n    return (domNode as HTMLElement).setAttribute != null\n}\n\nfunction removeAllDomNodeAttrsAndEvents(domNode: HTMLElementOrText, props: ElementProps<any>) {\n    const { events, attrs } = extractAttrsAndEventsFromProps(props)\n\n    // remove all events\n    for (let eventName in events) {\n        const eventValue = events[eventName]\n        domNode.removeEventListener(eventName, eventValue)\n    }\n\n     // remove all attrs\n    for (let attrName in attrs) {\n        if (isHTMLElement(domNode)) {\n            domNode.removeAttribute(attrName)\n        } else {\n            domNode.nodeValue = ''\n        }\n    }\n}\n\nfunction selectAttrNameAndValue(key: string, originValue: any) {\n    let name = key\n    let value = originValue\n\n    if (key === 'htmlFor') {\n        name = key\n    } else if (key === 'className') {\n        name = 'class'\n    } else if (key === 'style' && typeof value === 'object') {\n        value = Object.keys(value).map(key => `${key}: ${value[key]}`).join(';')\n    } else if (key === 'children') {\n        return null\n    } else {\n        name = name.toLowerCase()\n    }\n\n    return { name, value }\n}\n\nexport default dispatcher\n","import { Hook, FiberNode, HookEffect } from \"../reax\";\nimport { update } from './reconcile'\n\nlet workInProgressHook: Hook | null = null\nlet workInProgressFiberNode: FiberNode | null = null\n\nlet componentUpdateQueue: HookEffect[] = []\n\nexport function setWorkInProgressFiberNode(fiberNode: FiberNode) {\n    workInProgressFiberNode = fiberNode\n}\n\nexport function resetWorkInProgressHook() {\n    if (workInProgressFiberNode) {\n        // mark component fiber as mounted\n        workInProgressFiberNode.updateQueue = componentUpdateQueue\n    }\n    workInProgressHook = null\n    componentUpdateQueue = []\n}\n\nfunction isHookOnUpdateStage() {\n    return !!(workInProgressFiberNode && workInProgressFiberNode.isMount)\n}\n\nfunction mountWorkInProgressHook<S>() {\n    const hook: Hook<S> = {\n        memoizedState: null,\n        dispatch: null,\n        next: null\n    }\n\n    if (workInProgressHook === null) {\n        // first hook of hook link list\n        workInProgressHook = hook\n        // save in work-in-progress fiber\n        if (workInProgressFiberNode) {\n            workInProgressFiberNode.hooks = workInProgressHook\n        }\n    } else {\n        workInProgressHook.next = hook\n        workInProgressHook = workInProgressHook.next\n    }\n\n    return hook\n}\n\n\nfunction updateWorkInProgressHook<S>() {\n    // hooks never be null\n    let hook: Hook<S> | null = null\n    if (workInProgressHook === null) {\n        hook = workInProgressFiberNode!.hooks!\n    } else {\n        hook = workInProgressHook.next!\n    }\n    workInProgressHook = hook\n\n    return hook\n}\n\nfunction isInitStateFunc<S>(initState: S | (() => S)): initState is () => S {\n    return typeof initState === 'function'\n}\n\nfunction baseReducer<S, A>(state: S, action: A) {\n    return typeof action === 'function' ? action(state) : action\n}\n\n// useState\nfunction mountUseState<S>(initState: S | (() => S)): [S, (newState: S) => void] {\n    const calcInitState = isInitStateFunc(initState) ? initState() : initState\n    return mountUseReducer(baseReducer, calcInitState)\n}\n\nfunction updateUseState<S>(): [S | null, ((newState: S) => void) | null] {\n    return updateUseReducer(baseReducer)\n}\n\n// useReducer\nfunction mountUseReducer<S, A>(reducer: (state: S, action: A) => S, initState: S): [S, (action: A) => void] {\n    const hook = mountWorkInProgressHook<S>()\n    const memoizedState = hook.memoizedState = initState\n    const currentFiberNode = workInProgressFiberNode\n    const dispatch =  hook.dispatch = (action: A) => dispatchAction(hook, currentFiberNode, reducer(initState, action))\n    return [memoizedState, dispatch]\n}\n\nfunction updateUseReducer<S, A>(reducer: (state: S, action: A) => S): [S | null, (action: A) => void] {\n    const hook = updateWorkInProgressHook<S>()\n    const currentFiberNode = workInProgressFiberNode\n    const dispatch = hook.dispatch = (action: A) => dispatchAction(hook, currentFiberNode, reducer(hook.memoizedState as S, action))\n    return [hook.memoizedState, dispatch]\n}\n\n// useEffect\nfunction mountUseEffect(create: () => (() => void) | void, deps?: any[]) {\n    const hook = mountWorkInProgressHook<HookEffect>()\n    const nextDeps = deps === undefined ? null : deps\n    hook.memoizedState = pushHookEffect(create, null, nextDeps)\n}\n\nfunction updateUseEffect(create: () => (() => void) | void, deps?: any[]) {\n    const hook = updateWorkInProgressHook<HookEffect>()\n    const nextDeps = deps === undefined ? null : deps\n    const hookEffect: HookEffect | null = hook.memoizedState\n    const prevDeps = hookEffect && hookEffect.deps || null\n\n    if (!isEqualDeps(prevDeps, nextDeps)) {\n        const destroy = hookEffect && hookEffect.destroy || null\n        hook.memoizedState = pushHookEffect(create, destroy, nextDeps)\n    }\n}\n\n// useMemo\nfunction mountUseMemo<T>(nextCreate: () => T, deps?: any[] | null) {\n    const hook = mountWorkInProgressHook<[T, any[] | null]>()\n    const nextDeps = deps === undefined ? null : deps\n    const nextValue = nextCreate()\n    hook.memoizedState = [nextValue, nextDeps]\n    return nextValue\n}\n\nfunction updateUseMemo<T>(nextCreate: () => T, deps?: any[] | null) {\n    const hook = updateWorkInProgressHook<[T, any[] | null]>()\n    const nextDeps = deps === undefined ? null : deps\n    const [_, prevDeps] = hook.memoizedState!\n\n    if (!isEqualDeps(prevDeps, nextDeps))  {\n        const nextValue = nextCreate()\n        hook.memoizedState = [nextValue, nextDeps]\n    }\n    return hook.memoizedState![0]\n}\n\n// useCallback\nfunction mountUseCallback<T>(callback: T, deps?: any[] | null) {\n    const hook = mountWorkInProgressHook<[T, any[] | null]>()\n    const nextDeps = deps === undefined ? null : deps\n    hook.memoizedState = [callback, nextDeps]\n    return callback\n}\n\nfunction updateUseCallback<T>(callback: T, deps?: any[] | null) {\n    const hook = updateWorkInProgressHook<[T, any[] | null]>()\n    const nextDeps = deps === undefined ? null : deps\n    const [_, prevDeps] = hook.memoizedState!\n\n    if (!isEqualDeps(prevDeps, nextDeps)) {\n        hook.memoizedState = [callback, nextDeps]\n    }\n    return hook.memoizedState![0]\n}\n\n// useRef\nfunction mountUseRef<T>(initValue: T) {\n    const hook = mountWorkInProgressHook<{current: T}>()\n    const ref = { current: initValue }\n    hook.memoizedState = ref\n    return ref\n}\n\nfunction updateUseRef<T>() {\n    const hook = updateWorkInProgressHook<{current: T}>()\n    return hook.memoizedState\n}\n\nfunction isEqualDeps(prevDeps: any[] | null, nextDeps: any[] | null) {\n    prevDeps = prevDeps || []\n    nextDeps = nextDeps || []\n    for (let i = 0; i < Math.min(prevDeps.length, nextDeps.length); i++) {\n        if (Object.is(prevDeps[i], nextDeps[i])) {\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunction pushHookEffect(create: () => (() => void) | void, destroy: (() => void) | null, deps: any[] | null) {\n    const effect: HookEffect = {\n        create,\n        destroy,\n        deps\n    }\n    componentUpdateQueue.push(effect)\n    return effect\n}\n\nfunction dispatchAction<S>(hook: Hook<S>, fiberNode: FiberNode | null, newState: S) {\n    if (fiberNode) {\n        hook.memoizedState = newState\n        update(fiberNode)\n    }\n}\n\nfunction useState<S>(initState: S) {\n    if (isHookOnUpdateStage()) {\n        return updateUseState()\n    }\n\n    return mountUseState(initState)\n}\n\nfunction useReducer<S, A>(reducer: (state: S, action: A) => S, initState: S) {\n    if (isHookOnUpdateStage()) {\n        return updateUseReducer(reducer)\n    }\n\n    return mountUseReducer(reducer, initState)\n}\n\nfunction useEffect(create: () => (() => void) | void, deps?: any[]) {\n    if (isHookOnUpdateStage()) {\n        return updateUseEffect(create, deps)\n    }\n\n    return mountUseEffect(create, deps)\n}\n\nfunction useMemo<T>(nextCreate: () => T, deps?: any[] | null) {\n    if (isHookOnUpdateStage()) {\n        return updateUseMemo(nextCreate, deps)\n    }\n\n    return mountUseMemo(nextCreate, deps)\n}\n\nfunction useCallback<T>(callback: T, deps?: any[] | null) {\n    if (isHookOnUpdateStage()) {\n        return updateUseCallback(callback, deps)\n    }\n\n    return mountUseCallback(callback, deps)\n}\n\nfunction useRef<T>(initValue: T) {\n    if (isHookOnUpdateStage()) {\n        return updateUseRef()\n    }\n\n    return mountUseRef(initValue)\n}\n\nexport {\n    useState,\n    useReducer,\n    useEffect,\n    useMemo,\n    useCallback,\n    useRef\n}\n","import { createRootFiberNode, createWorkInProgressRootFiberNode } from './fiber'\nimport { ENOUGH_TIME, ROOT_FIBER_NODE } from './constants'\nimport dispatcher from './dispatcher'\nimport { isComponent } from './utils'\nimport { transformElementInputsToElements } from './element'\nimport { FiberNode, ElementInput, FunctionComponent, Element, RootHTMLElementWithFiberNode } from '../reax'\nimport { EffectTag, FiberNodeTag } from '../interface'\nimport { setWorkInProgressFiberNode, resetWorkInProgressHook } from './hook'\n\nlet taskQueue: FiberNode[] = []\n\nconst requestIdleCallback = window.requestIdleCallback || ((callback: (deadline: RequestIdleCallbackDeadline) => void) => {\n    callback({\n        didTimeout: true,\n        timeRemaining: () => 100\n    })\n})\n\nlet nextUnitWork: FiberNode | null = null\nlet workInProgressRootFiberNode: FiberNode | null = null\n\nexport function render(element: ElementInput, containerDom: HTMLElement) {\n    // clear all before render\n    dispatcher.clearDomContent(containerDom)\n    const rootFiberNode = createRootFiberNode(element, containerDom)\n    taskQueue.push(rootFiberNode)\n\n    requestIdleCallback(performWork)\n    return containerDom\n}\n\nexport function update(fiberNode: FiberNode) {\n    fiberNode.isPartialStateChanged = true\n    const oldRootFiberNode = workInProgressRootFiberNode\n    if (oldRootFiberNode) {\n        const rootFiberNode = createWorkInProgressRootFiberNode(oldRootFiberNode)\n        taskQueue.push(rootFiberNode)\n\n        // when no task in process, start work\n        if (!nextUnitWork) {\n            requestIdleCallback(performWork)\n        }\n    }\n}\n\nfunction performWork(deadline: RequestIdleCallbackDeadline) {\n    nextUnitWork = resolveNextUnitWork()\n    if (!nextUnitWork) {\n        commitAllWork()\n        return\n    }\n\n    if (deadline.timeRemaining() > ENOUGH_TIME) {\n        nextUnitWork = performUnitWork(nextUnitWork)\n    }\n\n    requestIdleCallback(performWork)\n}\n\nfunction resolveNextUnitWork() {\n    nextUnitWork = nextUnitWork || flushTaskQueue() || null\n\n    // update work-in-progress root fiber\n    if (nextUnitWork && nextUnitWork.tag === FiberNodeTag.HOST_ROOT_NODE) {\n        workInProgressRootFiberNode = nextUnitWork\n    }\n\n    return nextUnitWork\n}\n\nfunction flushTaskQueue() {\n    // flush taskQueue and use last task as next task\n    // all the current tasks should be merge as one task because they has same root fiber node\n    const task = taskQueue.shift()\n    taskQueue.length = 0\n\n    return task\n}\n\nfunction commitAllWork() {\n    if (workInProgressRootFiberNode) {\n        // save root fiber\n        (workInProgressRootFiberNode.statNode as RootHTMLElementWithFiberNode)[ROOT_FIBER_NODE] = workInProgressRootFiberNode\n        dispatcher.render(workInProgressRootFiberNode)\n    }\n}\n\nfunction performUnitWork(unitWork: FiberNode) {\n    let fiberNode: FiberNode | null = unitWork\n    beginUnitWork(fiberNode)\n\n    if (fiberNode.child) {\n        return fiberNode.child\n    }\n\n    while(fiberNode) {\n        completeUnitWork(fiberNode)\n        if (fiberNode.sibling) {\n            return fiberNode.sibling\n        }\n        fiberNode = fiberNode.parent || null\n    }\n\n    return null\n}\n\nfunction beginUnitWork(fiberNode: FiberNode) {\n    if (isComponent(fiberNode.type)) {\n        beginComponentNodeUnitWork(fiberNode)\n    } else (\n        beginHostNodeUnitWork(fiberNode)\n    )\n}\n\nfunction beginComponentNodeUnitWork(fiberNode: FiberNode) {\n    const Component = fiberNode.type as FunctionComponent\n    const alternateFiberNode = fiberNode.alternate\n\n    // TODO: judge props whether equal\n    if (alternateFiberNode && alternateFiberNode.props === fiberNode.props && !alternateFiberNode.isPartialStateChanged) {\n        cloneChildFiberNodes(fiberNode)\n        // reset update tag\n        alternateFiberNode.isPartialStateChanged = false\n    } else {\n        // set work-in-progress fiber to use in hooks\n        setWorkInProgressFiberNode(fiberNode)\n        const children = transformElementInputsToElements(Component(fiberNode.props))\n        fiberNode.isMount = true\n        resetWorkInProgressHook()\n        reconcileChildren(children, fiberNode)\n    }\n}\n\nfunction cloneChildFiberNodes(parentFiberNode: FiberNode) {\n    let oldFiberNode = parentFiberNode.alternate!.child\n    let prevFiberNode: FiberNode | null = null\n\n    while (oldFiberNode != null) {\n        const newFiberNode = {\n            ...oldFiberNode,\n            // update effect tag\n            effectTag: mergeEffectTag(EffectTag.NOTHING, oldFiberNode),\n            alternate: oldFiberNode,\n            parent: parentFiberNode,\n        }\n\n        if (prevFiberNode === null) {\n            parentFiberNode.child = newFiberNode\n        } else {\n            (prevFiberNode as FiberNode).sibling = newFiberNode\n        }\n\n        prevFiberNode = newFiberNode\n        oldFiberNode = oldFiberNode.sibling\n    }\n}\n\nfunction beginHostNodeUnitWork(fiberNode: FiberNode) {\n    const { children } = fiberNode\n    reconcileChildren(children, fiberNode)\n}\n\nfunction reconcileChildren(children: Element[], fiberNode: FiberNode) {\n    const alternateParentFiberNode = fiberNode.alternate\n    // fiber node chain\n    let prevChildFiberNode: FiberNode | null = null\n    let alternateChildFiberNode: FiberNode | null = null\n    for (let i = 0; i < children.length; i++) {\n        const childElement = children[i]\n        const childFiberNode = transformElementToFiberNode(childElement)\n        if (i === 0) {\n            fiberNode.child = childFiberNode\n            alternateChildFiberNode = alternateParentFiberNode && alternateParentFiberNode.child || null\n        } else {\n            prevChildFiberNode!.sibling = childFiberNode\n            alternateChildFiberNode = alternateChildFiberNode && alternateChildFiberNode.sibling || null\n        }\n        childFiberNode.parent = fiberNode\n        childFiberNode.alternate = alternateChildFiberNode || null\n        childFiberNode.statNode = alternateChildFiberNode && alternateChildFiberNode.statNode || null\n        childFiberNode.isMount = alternateChildFiberNode && alternateChildFiberNode.isMount || false\n        // copy hooks\n        childFiberNode.hooks = alternateChildFiberNode && alternateChildFiberNode.hooks || null\n\n        const effectTag = resolveEffectTag(childElement, alternateChildFiberNode)\n        childFiberNode.effectTag = mergeEffectTag(effectTag, alternateChildFiberNode)\n\n        prevChildFiberNode = childFiberNode\n    }\n\n    if (alternateChildFiberNode && alternateChildFiberNode.sibling) {\n        resolveAlternateFiberNodesAsRemoveEffectTag(alternateChildFiberNode.sibling, fiberNode)\n    }\n}\n\nfunction transformElementToFiberNode(element: Element): FiberNode {\n    const fiberNode = {\n        tag: isComponent(element.type) ? FiberNodeTag.COMPONENT_NODE : FiberNodeTag.HOST_NODE,\n        ...element,\n        effects: [],\n        statNode: null\n    }\n    return fiberNode\n}\n\nfunction resolveEffectTag(element: Element, alternateFiberNode: FiberNode | null): EffectTag {\n    if (alternateFiberNode) {\n        if (element.type === alternateFiberNode.type) {\n            if (element.props === alternateFiberNode.props) {\n                return EffectTag.NOTHING\n            }\n            return EffectTag.UPDATE\n        } else {\n            return EffectTag.REPLACE\n        }\n    }\n\n    return EffectTag.ADD\n}\n\nfunction mergeEffectTag(currentEffectTag: EffectTag, alternateFiberNode: FiberNode | null): EffectTag | null {\n    // merge effect if alternateFiberNode has effectTag\n    // all effectTag will be reset after render\n    // so if there any effectTag in alternateFiberNode, we should merge it with currentTag\n    const oldEffectTag = alternateFiberNode && alternateFiberNode.effectTag || null\n    if (!oldEffectTag) {\n        return currentEffectTag\n    }\n\n    if (alternateFiberNode) {\n        alternateFiberNode.effectTag = EffectTag.NOTHING\n    }\n    return Math.max(currentEffectTag, oldEffectTag)\n}\n\nfunction resolveAlternateFiberNodesAsRemoveEffectTag(alternateFiberNode: FiberNode | null, fiberNode: FiberNode) {\n    if (alternateFiberNode) {\n        alternateFiberNode.effectTag = EffectTag.REMOVE\n        fiberNode.effects.push(alternateFiberNode)\n    }\n}\n\nfunction completeUnitWork(fiberNode: FiberNode) {\n    const parentFiberNode = fiberNode.parent\n    const effects = fiberNode.effects\n\n    // commit hooks\n    commitUnitWorkHooks(fiberNode)\n\n    if (parentFiberNode) {\n        if (fiberNode.effectTag) {\n            parentFiberNode.effects.push(fiberNode)\n        }\n        parentFiberNode.effects.push(...effects)\n        // reset effects\n        fiberNode.effects = []\n    }\n}\n\nfunction commitUnitWorkHooks(fiberNode: FiberNode) {\n    const updateQueue = fiberNode.updateQueue || []\n    // reset updateQueue\n    for (let i = 0; i < updateQueue.length; i++) {\n        const hookEffect = updateQueue[i]\n        const { create, destroy } = hookEffect\n        if (destroy) {\n            destroy()\n        }\n        if (create) {\n            hookEffect.destroy = create() || null\n        }\n    }\n    fiberNode.updateQueue = []\n}\n","import { FiberNode, ElementInput, RootHTMLElementWithFiberNode } from \"../reax\";\nimport { FiberNodeTag } from '../interface'\nimport { transformElementInputsToElements } from \"./element\";\n\nexport function createRootFiberNode(element: ElementInput | ElementInput[], statNode: RootHTMLElementWithFiberNode): FiberNode {\n    return {\n        tag: FiberNodeTag.HOST_ROOT_NODE,\n        children: transformElementInputsToElements(element),\n        effects: [],\n        statNode,\n        alternate: null\n    }\n}\n\nexport function createWorkInProgressRootFiberNode(fiberNode: FiberNode) {\n    return {\n        tag: FiberNodeTag.HOST_ROOT_NODE,\n        children: fiberNode.children,\n        effects: fiberNode.effects,\n        statNode: fiberNode.statNode,\n        alternate: fiberNode\n    }\n}\n","import { createElement } from './element'\nimport { render } from './reconcile'\nimport { useState, useReducer, useEffect, useCallback, useMemo, useRef } from './hook'\n\nexport default {\n    createElement,\n    render,\n    useState,\n    useReducer,\n    useEffect,\n    useCallback,\n    useMemo,\n    useRef\n}\n"],"sourceRoot":""}